$$HEADER$$
<a name="overview" /><h3>Overview</h3>
<p>Since Lua doesn't have (yet) built-in capabilities for bit operations, the <b>bit</b> module was added to <b>eLua</b> to fill this gap. It is based on the <a href="http://luaforge.net/projects/bitlib">bitlib</a>   library written by Reuben Thomas (slightly adapted to <b>eLua</b>) and provides basic bit operations (like setting and clearing bits) and bitwise operations.</p>

<a name="funcs" /><h3>Functions</h3>
<div class="docdiv">
<a name="bit.bit" /><pre><code>number = bit.bit( position )</code></pre>
<p>Generate a number with a 1 bit (used for mask generation). Equivalent to <i>1 &lt;&lt; position</i> in C.</p>
<p><b>Arguments</b>: <b>position</b> - position of the bit that will be set to 1.</p>
<p><b>Returns</b>: <b>number</b> - a number with only one 1 bit at <b>position</b> (the rest are set to 0).</p>

<a name="bit.isset" /><pre><code>flag = bit.isset( value, position )</code></pre>
<p>Test if a given bit is set.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the value to test.</li>
  <li><b>position</b> - bit position to test.</li>
</ul>
<p><b>Returns</b>: <b>boolean</b> - true if the bit at the given position is 1, false otherwise.</p>

<a name="bit.isclear" /><pre><code>flag = bit.isclear( value, position )</code></pre>
<p>Test if a given bit is cleared.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the value to test.</li>
  <li><b>position</b> - bit position to test.</li>
</ul>
<p><b>Returns</b>: <b>boolean</b> - true if the bit at the given position is 0, false othewise.</p>

<a name="bit.set" /><pre><code>number = bit.set( value, pos1, pos2, ..., posn )</code></pre>
<p>Set bits in a number.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the base number.</li>
  <li><b>pos1</b> - position of the first bit to set.</li>
  <li><b>pos2</b> - position of the second bit to set.</li>
  <li><b>posn</b> - position of the nth bit to set.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the number with the bit(s) set in the given position(s).</p>

<a name="bit.clear" /><pre><code>number = bit.clear( value, pos1, pos2, ..., posn )</code></pre>
<p>Clear bits in a number.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the base number.</li>
  <li><b>pos1</b> - position of the first bit to clear.</li>
  <li><b>pos2</b> - position of the second bit to clear.</li>
  <li><b>posn</b> - position of thet nth bit to clear.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the number with the bit(s) cleared in the given position(s).</p>

<a name="bit.bnot" /><pre><code>number = bit.bnot( value )</code></pre>
<p>Bitwise negation, equivalent to <i>~value</i> in C.</p>
<p><b>Arguments</b>: <b>value</b> - the number to negate.</p>
<p><b>Returns</b>: <b>number</b> - the bitwise negated value of the number.</p>

<a name="bit.band" /><pre><code>number = bit.band( val1, val2, ... valn )</code></pre>
<p>Bitwise AND, equivalent to <i>val1 &amp; val2 &amp; ... &amp; valn</i> in C.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>val1</b> - first AND argument.</li>
  <li><b>val2</b> - second AND argument.</li>
  <li><b>valn</b> - nth AND argument.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the bitwise AND of all the arguments.</p>

<a name="bit.bor" /><pre><code>number = bit.bor( val1, val2, ... valn )</code></pre>
<p>Bitwise OR, equivalent to <i>val1 | val2 | ... | valn</i> in C.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>val1</b> - first OR argument.</li>
  <li><b>val2</b> - second OR argument.</li>
  <li><b>valn</b> - nth OR argument.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the bitwise OR of all the arguments.</p>

<a name="bit.bxor" /><pre><code>number = bit.bxor( val1, val2, ... valn )</code></pre>
<p>Bitwise exclusive OR (XOR), equivalent to <i>val1 ^ val2 ^ ... ^ valn</i> in C.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>val1</b> - first XOR argument.</li>
  <li><b>val2</b> - second XOR argument.</li>
  <li><b>valn</b> - nth XOR argument.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the bitwise exclusive OR of all the arguments.</p>

<a name="bit.lshift" /><pre><code>number = bit.lshift( value, shift )</code></pre>
<p>Left-shift a number, equivalent to <i>value &lt; shift</i> in C.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the value to shift.</li>
  <li><b>shift</b> - positions to shift.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the number shifted left</p>

<a name="bit.rshift" /><pre><code>number = bit.rshift( value, shift )</code></pre>
<p>Logical right shift a number, equivalent to <i>( unsigned )value &gt;&gt; shift</i> in C.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the value to shift.</li>
  <li><b>shift</b> - positions to shift.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the number shifted right (logically).</p>

<a name="bit.arshift" /><pre><code>number = bit.arshift( value, shift )</code></pre>
<p>Arithmetic right shift a number equivalent to <i>value &gt;&gt; shift</i> in C.</p>
<p><b>Arguments</b>: </p>
<ul>
  <li><b>value</b> - the value to shift.</li>
  <li><b>shift</b> - positions to shift.</li>
</ul>
<p><b>Returns</b>: <b>number</b> - the number shifted right (arithmetically).</p>

</div>
$$FOOTER$$
